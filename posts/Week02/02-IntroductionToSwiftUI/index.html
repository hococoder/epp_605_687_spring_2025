<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Mobile Application Development for the iOS Platform"/><link rel="canonical" href="https://hococoder.com/posts/Week02/02-IntroductionToSwiftUI"/><meta name="twitter:url" content="https://hococoder.com/posts/Week02/02-IntroductionToSwiftUI"/><meta name="og:url" content="https://hococoder.com/posts/Week02/02-IntroductionToSwiftUI"/><title>Week 2 - Introduction to SwiftUI | Mobile Application Development for the iOS Platform</title><meta name="twitter:title" content="Week 2 - Introduction to SwiftUI | Mobile Application Development for the iOS Platform"/><meta name="og:title" content="Week 2 - Introduction to SwiftUI | Mobile Application Development for the iOS Platform"/><meta name="description" content="An introduction to making user interfaces with SwiftUI."/><meta name="twitter:description" content="An introduction to making user interfaces with SwiftUI."/><meta name="og:description" content="An introduction to making user interfaces with SwiftUI."/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="../../../styles.css" type="text/css"/><script src="../../../../jquery-3.7.1.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Mobile Application Development for the iOS Platform"/></head><body><div class="layout"><div class="header"><div class="headerLayout"><div class="title">Mobile Application Development for the iOS Platform</div><div class="subtitle">Engineering Program for Professionals - 605.687 - 2024-2025 Academic Year</div><div class="weeklayout"><a class="grow1" href="/epp_605_687_spring_2025/posts/Intro/About Me">About Me</a><a class="grow1" href="/epp_605_687_spring_2025/posts/Intro/Example App">Example App</a><a class="grow1" href="/epp_605_687_spring_2025/posts/Week00/00-Week00Overview">Week 0</a><a class="grow1" href="/epp_605_687_spring_2025/posts/Week01/00-Week01Overview">Week 1</a><a class="grow1" href="/epp_605_687_spring_2025/posts/Week02/00-Week02Overview">Week 2</a><a class="grow1" href="/epp_605_687_spring_2025/posts/Week03/00-Week03Overview">Week 3</a><a class="grow1" href="/epp_605_687_spring_2025/posts/Week04/00-Week04Overview">Week 4</a><a class="grow1" href="/epp_605_687_spring_2025/posts/Week05/00-Week05Overview">Week 5</a><a class="grow1" href="/epp_605_687_spring_2025/posts/Week06/00-Week06Overview">Week 6</a><a class="grow1" href="/epp_605_687_spring_2025/posts/Week07/00-Week07Overview">Week 7</a><a class="grow1" href="/epp_605_687_spring_2025/posts/Week08/00-Week08Overview">Week 8</a><a class="grow1" href="/epp_605_687_spring_2025/posts/Week09/00-Week09Overview">Week 9</a><a class="grow1" href="/epp_605_687_spring_2025/posts/Week10/00-Week10Overview">Week 10</a><a class="grow1" href="/epp_605_687_spring_2025/posts/Week11/00-Week11Overview">Week 11</a><a class="grow1" href="/epp_605_687_spring_2025/posts/Week12/00-Week12Overview">Week 12</a><a class="grow1" href="/epp_605_687_spring_2025/posts/Week13/00-Week13Overview">Week 13</a></div></div></div><div class="wrapper"><h1>Week 2 - Introduction to SwiftUI</h1><p style="float: left">Previous:  <A HREF="../../Week02/01-TheDelegatePattern/index.html">The Delegate Pattern</A></p><p style="float: right">Next:  <A HREF="../../Week02/03-SwiftUIState/index.html">SwiftUI State</A></p><BR/><BR/><p class="suggestedReading">
For a great Summary of SwiftUI, you can check out <A HREF="https://goshdarnswiftui.com">Gosh Darn SwiftUI</A> which has a great breakdown of each of the elements.  
</p><p>Now since we have our model in place, let's setup the user interface for our screens. Before we do that however, let's look at some part of Xcode you'll need to work with SwiftUI (you'll learn more about the Xcode interface later in this module)</p><a name="usingSwiftui"></a>
<h2>Using SwiftUI</h2><div id="floater">
<h3><u>Page Contents</u></h3>
<ul><li><a href="#usingSwiftui">Using SwiftUI</a></li><li><a href="#swiftuiBasics">SwiftUI Basics</a></li></ul></div><center><iframe id="myIframe" src="https://jh.hosted.panopto.com/Panopto/Pages/Embed.aspx?id=5dd698c6-c432-43c9-8729-b1ac013c7d22&autoplay=false&offerviewer=true&showtitle=true&showbrand=true&captions=false&interactivity=all"  style="border: 1px solid #464646;" allowfullscreen allow="autoplay" aria-label="Panopto Embedded Video Player" aria-description="Week0-04-THIRDPARTYTOOLS-Lecture" ></iframe></center><p>There are 2 different ways in Xcode to build user interfaces using SwiftUI, but both of them involve the use of the Preview Canvas to get an idea of what your UI will actually look like. If you start a project and specify SwiftUI as the interface type, a ContentView.swift file will get generated for you. This is the default user interface file and that will get launched if we were to run the app in the simulator.</p><img src="../../../week02/ContentView.png#centerResizedSlide" alt="ContentView"/><p>When you open a file that can be used to render UI via SwiftUI, the editor will show a split configuration - code on the left, and a preview canvas on the right. You'll notice that the top of the preview canvas says "Preview paused" - this will appear on the first entry into the file, as well as when large changes to the source take place, so you have a little more control over when the preview gets updated. Otherwise, Xcode would make an attempt to keep the preview up to date as you type. If you press that button now, it will update the preview canvas and show you the prototypical "Hello World".<br><br><img src="../../../week02/ResumeButton.png#centerResizedSlide" alt="ResumeButton"/></p><p>We'll build some UI with both code and drag and drop later in the module, but I wanted to show you the library before that happens. In the upper right hand corner of Xcode you'll see a Plus button. If you click on this, a library pane will open up. Normally this can give you access to things like built in code snippets, media and colors, but when you have a SwiftUI file open, also give you two additional tabs - views and modifiers.<br><br><img src="../../../week02/Library.png#centerResizedSlide" alt="Library"/></p><p>Under the views tab you'll see all the various SwiftUI views that you can drag right into the preview canvas (which will also add it to the source code!), including view layout objects and gradients you can use in your code. The modifiers tab shows you the list of modifiers (of course), events, and gestures you can apply to the views you load into the canvas. In addition to being able to drop these objects into the preview canvas, you can also drag then into the source code!</p><p>You might be wondering where the UI in the preview canvas comes from - well, if you look at the bottom of the <code>ContentView.swift</code> file, you'll see a <code>#Previews</code> macro. We'll see how to adopt this preview macro to show various things later in this week's lecture, but basically, anything listed in this macro's closure will get placed into the Preview Canvas.</p><pre><code>#Preview {
    <span class="type">ContentView</span>()
}
</code></pre><a name="swiftuiBasics"></a>
<h2>SwiftUI Basics</h2><p>The EPExampleApp project (see the resources bundle for this week) has an app to demo certain aspects of iOS throughout the semester. For this week, the example app provides demos of the various SwiftUI widget. Let's take a look at some of the basic SwiftUI widgets now - you'll see others later in on the semester.<br><br></p><p class="info">To see these in action, please load the Example App project, go to Week02View.swift, hit resume in the Preview Canvas, and then hit the play button at the top of the simulator to have it go "live" - you'll be able to interact with it as you would the normal simulator.  If for some reason it stalls or gives you an error, you may have to click resume again (it is sadly not a perfect science to get the preview canvas up and running sometimes, but it *does* work).  You can also run the entire project in the simulator and choose week 2 from the listing when the app starts. </p><p class="info">There are "Preview" buttons in some of the code blocks. If you hover over the word "Preview" it will show you what the rendered view should look like!</p><h3><code>Text</code></h3><p>The closest equivalent to a <code>JLabel</code> in Java in the <code>Text</code> field. The initializer takes in the text you want to display.</p><div class="code-preview">
   <a>
       Preview <img src="../../../week02/text.png"/>
   </a>
</div><pre><code><span class="type">Text</span>(<span class="string">"Your text here"</span>)
</code></pre><h3><code>TextField</code></h3><p>An input field is represented by the <code>TextField</code> class. Note that the argument to the <code>text</code> argument has a <code>$</code> preceding it. We'll talk about what that means in the module on Swift UI State. Also notice there is a method call on the <code>TextField</code> called <code>textFieldStyle</code> - this is a modifier, which you'll learn about below.</p><div class="code-preview">
   <a>
       Preview <img src="../../../week02/textField.png"/>
   </a>
</div><pre><code><span class="type">TextField</span>(<span class="string">"Username"</span>, text: <span class="property">$username</span>)
  .<span class="call">textFieldStyle</span>(<span class="type">RoundedBorderTextFieldStyle</span>())
</code></pre><h3><code>SecureField</code></h3><p>If you want to take in user input, but want to keep it secret - like when dealing with passwords - you can use <code>SecureField</code></p><div class="code-preview">
   <a>
       Preview <img src="../../../week02/secureField.png"/>
   </a>
</div><pre><code><span class="type">SecureField</span>(<span class="string">"Password"</span>, text: <span class="property">$password</span>)
  .<span class="call">textFieldStyle</span>(<span class="type">RoundedBorderTextFieldStyle</span>())
</code></pre><h3><code>TextEditor</code></h3><p>A new widget in iOS14 is <code>TextEditor</code> - which is just what it sounds like. An editable text field that can contain 1 or more lines.</p><div class="code-preview">
   <a>
       Preview <img src="../../../week02/textEditor.png"/>
   </a>
</div><pre><code><span class="type">TextEditor</span>(text: <span class="property">$someSampleText</span>)
</code></pre><h3><code>Image</code></h3><p>Images have a few different initializers, and can take in some important modifiers. Let's look at some examples.</p><p>The first initializer takes 2 arguments: one, the name of the image, which in this case is the name in the Assets catalog (Assets.xcassets in the project) without the extension, and a <code>label</code> argument which is used for accessibility reasons (we'll talk about Accessibility later in the semester).</p><p>The 2 modifiers that come after it are important ones for working with Images: <code>resizable()</code> tells the layout system that this image can be resized; this will most likely be the case because the image you want to display will be larger than the screen you'll be displaying it on; <code>aspectRatio</code> here tells the layout system to allow this image to keep its aspect ratio, and allow it to be resized to fit in whatever frame it ends up being in. This will keep the image from being squished in one direction in the final layout.</p><div class="code-preview">
   <a>
       Preview <img src="../../../week02/image.png"/>
   </a>
</div><pre><code><span class="type">Image</span>(<span class="string">"cook_hero"</span>, label: <span class="type">Text</span>(<span class="string">"Tim Cook"</span>))
  .<span class="call">resizable</span>()
  .<span class="call">aspectRatio</span>(contentMode: .<span class="dotAccess">fit</span>)
</code></pre><p>A new initializer in iOS 17 takes advantage of the fact that all images and colors in the Assets catalog now get autogenerated static names that you can use instead of strings, for example:</p><pre><code><span class="type">Image</span>(<span class="string">"cookHero"</span>)
  .<span class="call">resizable</span>()
  .<span class="call">aspectRatio</span>(contentMode: .<span class="dotAccess">fit</span>)
</code></pre><p>Note here that the accessibility label is not available with this initializer, so you would have to add it another way.</p><p>Another simpler initializer takes in an argument for the parameter <code>systemName</code>, which means it is expecting the name of an image that is known to the system. Here, we're using a name from <a href="https://developer.apple.com/design/human-interface-guidelines/sf-symbols/overview/">SF Symbols</a>, which is a set of images provided by Apple for developers to use in their app development. Download it and give it a look - it is quite a nice resource.</p><div class="code-preview">
   <a>
       Preview <img src="../../../week02/sfSymbols.png"/>
   </a>
</div><pre><code><span class="type">Image</span>(systemName: <span class="string">"person.crop.circle"</span>)
</code></pre><p>You can now also easily animate SFSymbols as of iOS 17. Here's an example:</p><pre><code><span class="keyword">struct</span> DogView: <span class="type">View</span> {
    <span class="keyword">@State private var</span> petCount = <span class="number">0</span>

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">Button</span> {
            petCount += <span class="number">1</span>
        } label: {
            <span class="type">Label</span>(<span class="string">"Pet the Dog"</span>, systemImage: <span class="string">"dog"</span>)
        }
        .<span class="call">symbolEffect</span>(.<span class="dotAccess">bounce</span>, value: petCount)
        .<span class="call">font</span>(.<span class="dotAccess">largeTitle</span>)
    }
}
</code></pre><p>Try checking this one out in the EPExampleApp so you can see the bounce.</p><h3><code>Button</code></h3><p>There are a few different initializers for the Button type, and the one below uses a trailing closure to contain what should happen when the Button is pressed, while the first argument in the call is for the text of the button.</p><div class="code-preview">
   <a>
       Preview <img src="../../../week02/button.png"/>
   </a>
</div><pre><code><span class="type">Button</span>(<span class="string">"Press Me"</span>)
{
  <span class="keyword">self</span>.<span class="property">alertIsShowing</span> = <span class="keyword">true</span>
}
</code></pre><h3><code>Toggle</code></h3><p>A toggle switch can be created with the <code>Toggle</code> class. The <code>isOn</code> argument captures the current state, and the <code>label</code> describes the view attached to the toggle. Note here that it's not just text in front of the toggle; it's any view you can compose.</p><div class="code-preview">
   <a>
       Preview <img src="../../../week02/toggle1.png"/>
   </a>
</div><pre><code><span class="type">Toggle</span>(isOn: <span class="property">$toggleState</span>, label: { <span class="type">Text</span>(<span class="string">"Toggle On"</span>)})
</code></pre><p>You can also have the Toggle represented as a depressable button, which you can get with the <code>toggleStyle</code> modifier.</p><div class="code-preview">
   <a>
       Preview <img src="../../../week02/toggle2.png"/>
   </a>
</div><pre><code><span class="type">Toggle</span>(isOn: <span class="property">$toggleState</span>, label: { <span class="type">Text</span>(<span class="string">"Toggle On"</span>)})
  .<span class="call">toggleStyle</span>(.<span class="dotAccess">button</span>)
</code></pre><h3><code>Form</code>s and <code>Picker</code>s</h3><p>The <code>Form</code> type is used to group controls for data entry - pickers, text fields and more all get a nice grouping and display when in a form. The <code>Picker</code> type here is what most people would call a spinner - however when in a form, when you click on the picker it will take you to a new screen to show the possible choices you can choose from.</p><div class="code-preview">
   <a>
       Preview <img src="../../../week02/picker.png"/>
   </a>
</div><pre><code><span class="type">Form</span> {
  <span class="type">Picker</span>(selection: <span class="property">$pickerSelection</span>, label: <span class="type">Text</span>(<span class="string">"Picker Sample"</span>), content: {
    <span class="type">Text</span>(<span class="string">"Sample Value 1"</span>).<span class="call">tag</span>(<span class="number">0</span>)
    <span class="type">Text</span>(<span class="string">"Sample Value 2"</span>).<span class="call">tag</span>(<span class="number">1</span>)
    <span class="type">Text</span>(<span class="string">"Sample Value 3"</span>).<span class="call">tag</span>(<span class="number">2</span>)
  })
}
</code></pre><h3>Segmented Controls</h3><p>The segmented control is something you may have seen if you've searched in the Mail app on iOS - you get to choose between "All MailBoxes" and "Current Mailbox". The <code>selection</code> argument contains the selected state, and the <code>pickerStyle</code> modifier tells the layout system that this <code>Picker</code> should be displayed in the segmented control mode.</p><div class="code-preview">
   <a>
       Preview <img src="../../../week02/segmentedControl.png"/>
   </a>
</div><pre><code><span class="type">Picker</span>(selection: <span class="property">$pickerSelection</span>, label: <span class="type">Text</span>(<span class="string">"Picker Sample"</span>), content: {
  <span class="type">Text</span>(<span class="string">"Value 1"</span>).<span class="call">tag</span>(<span class="number">0</span>)
  <span class="type">Text</span>(<span class="string">"Value 2"</span>).<span class="call">tag</span>(<span class="number">1</span>)
  <span class="type">Text</span>(<span class="string">"Value 3"</span>).<span class="call">tag</span>(<span class="number">2</span>)
}).<span class="call">pickerStyle</span>(<span class="type">SegmentedPickerStyle</span>())
</code></pre><h3><code>DatePicker</code></h3><p>iOS 14 got a greatly enhanced date picker, which will pop up a new modal dialog with a natural date and time picker, instead of using the very hard to use spinner style that iOS has used for years.</p><div class="code-preview">
   <a>
       Preview <img src="../../../week02/datePicker.png"/>
   </a>
</div><pre><code><span class="type">Form</span> {
  <span class="type">DatePicker</span>(selection: <span class="property">$selectedDate</span>, displayedComponents: [.<span class="dotAccess">date</span>, .<span class="dotAccess">hourAndMinute</span>], label: {<span class="type">Text</span>(<span class="string">"Due"</span>)})
}
</code></pre><h3><code>Slider</code></h3><p>Sliders let you choose from a range of values by sliding a control left and right. The current value is captured in the variable pointed to by <code>value</code>.</p><div class="code-preview">
   <a>
       Preview <img src="../../../week02/slider.png"/>
   </a>
</div><pre><code><span class="type">HStack</span> {
  <span class="type">Slider</span>(value: <span class="property">$sliderValue</span>, in: <span class="number">0</span>...<span class="number">10</span>, step: <span class="number">0.1</span>)
  <span class="type">Text</span>(<span class="string">"</span>\(sliderValue)<span class="string">"</span>)
}
</code></pre><h3><code>Stepper</code></h3><p>Similar to <code>Slider</code>, <code>Stepper</code> lets you choose from a range of values, but here you are presented with +/- buttons to step between different values.</p><div class="code-preview">
   <a>
       Preview <img src="../../../week02/stepper.png"/>
   </a>
</div><pre><code><span class="type">HStack</span> {
  <span class="type">Stepper</span>(value: <span class="property">$stepperValue</span>, in: <span class="number">0</span>...<span class="number">10</span>, label: {<span class="type">Text</span>(<span class="string">"Step"</span>)})
  <span class="type">Text</span>(<span class="string">"</span>\(stepperValue)<span class="string">"</span>)
}
</code></pre><h3><code>Divider</code></h3><p>The <code>Divider</code> control is a simple control that puts a divider between other views.</p><pre><code><span class="type">Divider</span>()
</code></pre><h3><code>List</code>, <code>NavigationStack</code> and <code>NavigationLink</code></h3><p>This example has a few pieces to it. If you look at the ContentView.swift file in the Example App, you'll see the main containing view is a <code>NavigationStack</code>. This type of view is similar to <code>UINavigationController</code> in UIKit, and handles the cases where you will present a hierarchy of views - in our case, each week has a number of children to display - and will handle the navigation between those views and also provide back buttons automatically.<br><br>You also have the possibility of including titles for the navigation bar. In Week02View.swift, you'll see <code>.navigationBarTitle("SwiftUI Examples")</code> as a modifier on the <code>VStack</code>. This is important to note: the <code>navigationBarTitle</code> modifier and other related modifiers go on the view <strong>INSIDE</strong> the NavigationStack, not the <code>NavigationStack</code> itself.<br><br>As you can see in <code>ContentView.swift</code> one way to specify the elements of a <code>NavigationStack</code> is to place them within a <code>List</code>, which is simply a wrapper around those views you want to include (another way to specify a list of entries like this is to use a <code>ForEach</code> statement which you'll see later.)</p><div class="code-preview">
   <a>
       Preview <img src="../../../week02/navigationLink.png"/>
   </a>
</div><pre><code><span class="type">List</span> {
  <span class="type">NavigationLink</span>(destination: <span class="type">Text</span>(<span class="string">"Row 1"</span>), label: {<span class="type">Text</span>(<span class="string">"Row 1"</span>)})
  <span class="type">NavigationLink</span>(destination: <span class="type">Text</span>(<span class="string">"Row 2"</span>), label: {<span class="type">Text</span>(<span class="string">"Row 2"</span>)})
  <span class="type">Text</span>(<span class="string">"Row 3"</span>)
  <span class="type">Text</span>(<span class="string">"Row 4"</span>)
}
</code></pre><p>The first 2 entries here are special - they are <code>NavigationLink</code>s, which will display the view specified by the <code>label</code> argument for the row's title, and when tapped, send you to the view specified by the <code>destination</code> argument. This simple example contains <code>Text</code> views, but can be any complex view you want to use (see <code>ContentView.swift</code> for an example of this).</p><h3>NavigationStack</h3><p>Introduced in iOS 16, <code>NavigationStack</code> provides a new way to deal with NavigationLinks. In the example below, you have a view within which is a NavigationLink. Inside the <code>NavigationStack</code> is a list of those views, and on that list is a new modifier, called <code>.navigationDestination</code>. This particular instance of the modifier is specifically for when a <code>NavStackExampleItem</code> is encountered, which means you can have different behaviors for different items as long as you have a modifier that can handle them.</p><pre><code><span class="keyword">struct</span> NavStackExampleItemView: <span class="type">View</span> {

  <span class="keyword">var</span> item: <span class="type">NavStackExampleItem</span>

  <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
    <span class="type">NavigationLink</span>(value: item) {
      <span class="type">Text</span>(<span class="string">"Row</span> \(item.<span class="property">row</span>)<span class="string">"</span>)
    }
  }
}


<span class="type">NavigationStack</span> {
  <span class="type">List</span> {
    <span class="type">NavStackExampleItemView</span>(item: <span class="type">NavStackExampleItem</span>(row: <span class="number">0</span>))
    <span class="type">NavStackExampleItemView</span>(item: <span class="type">NavStackExampleItem</span>(row: <span class="number">1</span>))
    <span class="type">NavStackExampleItemView</span>(item: <span class="type">NavStackExampleItem</span>(row: <span class="number">2</span>))
    <span class="type">NavStackExampleItemView</span>(item: <span class="type">NavStackExampleItem</span>(row: <span class="number">3</span>))
  }
  .<span class="call">navigationDestination</span>(for: <span class="type">NavStackExampleItem</span>.<span class="keyword">self</span>) { item <span class="keyword">in</span>
    <span class="type">Text</span>(<span class="string">"This is row</span> \(item.<span class="property">row</span>)<span class="string">"</span>)
      .<span class="call">navigationTitle</span>(<span class="string">"Row</span> \(item.<span class="property">row</span>)<span class="string">"</span>)
  }
  .<span class="call">navigationBarTitle</span>(<span class="string">"Navigation Stack"</span>)
}
.<span class="call">titledBorder</span>(title: <span class="string">"List Example with NavigationStack"</span>, height: <span class="number">400</span>)
</code></pre><h3>Modal Views</h3><p>Modal views can be displayed by using the <code>.sheet</code> modifier. The <code>content</code> of the <code>.sheet</code> is displayed in a modal view that overlays the current view, and can be dismissed by swiping down.</p><pre><code><span class="type">Button</span>(<span class="string">"Press for Modal View"</span>)
{
  <span class="keyword">self</span>.<span class="property">modalIsShowing</span> = <span class="keyword">true</span>
}
.<span class="call">sheet</span>(isPresented: <span class="property">$modalIsShowing</span>, content: 
{
  <span class="type">Text</span>(<span class="string">"This is a modal!"</span>)
})
</code></pre><p>If you want to cover as much of the view as possible, use <code>fullScreenCover</code>. Note that in this case you'll have to use a member of the SwiftUI Environment - which we'll discuss in a few modules - to help dismiss the sheet.</p><pre><code><span class="type">Button</span>(<span class="string">"Press for Full Screen Cover View"</span>)
{
  <span class="keyword">self</span>.<span class="property">fullScreenIsShowing</span> = <span class="keyword">true</span>
}
.<span class="call">fullScreenCover</span>(isPresented: <span class="property">$fullScreenIsShowing</span>, content:
{
  <span class="type">FullScreen</span>()
})

<span class="keyword">struct</span> FullScreen: <span class="type">View</span> {
  <span class="keyword">@Environment</span>(\.<span class="property">dismiss</span>) <span class="keyword">private var</span> dismiss


  <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
    <span class="type">Text</span>(<span class="string">"This is a full screen modal!"</span>)
      .<span class="call">onTapGesture</span> {
        <span class="call">dismiss</span>()
      }
  }
}
</code></pre><h3><code>ProgressView</code></h3><p><code>ProgressView</code> can be used to display a progress indicator.</p><div class="code-preview">
   <a>
       Preview <img src="../../../week02/progress.png"/>
   </a>
</div><pre><code><span class="type">HStack</span> {
  <span class="type">ProgressView</span>(value: progress)
  <span class="type">Button</span>(<span class="string">"Add Progress"</span>, action: { progress += <span class="number">0.1</span> })
}
</code></pre><h3><code>ColorPicker</code></h3><p>iOS 14 also introduced a much needed improved color picker to the available widgets for developers. <code>ColorPicker</code> is the name of the widget, and the chosen color is stored in the property assigned in the <code>selection</code> argument.</p><div class="code-preview">
   <a>
       Preview <img src="../../../week02/colorPicker2.png"/>
   </a>
</div><pre><code><span class="type">ColorPicker</span>(<span class="string">"Color"</span>, selection: <span class="property">$color</span>)
</code></pre><h3>Inspector</h3><p>Inspector panels - like those you see in Xcode on the left and right hand sides - are now usable in iOS. Depending on the platform, they can either appear as a slideover (on iOS) or more like a Xcode like pane on iPadOS and macOS. All you need is a modifier on your view:</p><pre><code>.<span class="call">inspector</span>(isPresented: <span class="property">$isShowingInspector</span>) {
      <span class="type">Text</span>(<span class="string">"Inspector View"</span>)
}
</code></pre><p>Here, the closure shows whatever you want your Inspector to show, and the appearance is based on the current value of $isShowingInspector. The exact way it appears is taken care of behind the scenes by iOS. Check out the EPExampleApp project for an example of this - I've included an iPadOS preview so you can see how it works there versus iOS.</p><a name="modifiers"></a>
<h2>Modifiers</h2><h3>Built in Modifiers</h3><p>We talked about modifiers briefly above - let's dive in a little more.</p><p>Modifiers on Views do just that - they modify them in some way, and when they are done, return a new View (the old one is destroyed). However, depending on the modifier, the View that is returned may be of the same type, or it may be a more generic type. Let's take a look at the <code>Image</code> example from earlier:</p><pre><code><span class="type">Image</span>(<span class="string">"cook_hero"</span>, label: <span class="type">Text</span>(<span class="string">"Tim Cook"</span>))
  .<span class="call">resizable</span>()
  .<span class="call">aspectRatio</span>(contentMode: .<span class="dotAccess">fit</span>)
</code></pre><p>Let's look at the function signature for the <code>resizable()</code> modifier first:</p><pre><code><span class="keyword">func</span> resizable(capInsets: <span class="type">EdgeInsets</span> = <span class="type">EdgeInsets</span>(), resizingMode: <span class="type">Image</span>.<span class="type">ResizingMode</span> = .<span class="dotAccess">stretch</span>) -&gt; <span class="type">Image</span>
</code></pre><p>This shows that <code>resizable()</code> returns an Image, and has default values for each of its arguments, so <code>resizable()</code> is a valid call to the function, and it uses those defaults.<br><br>Next let's look at <code>aspectRatio</code></p><pre><code><span class="keyword">func</span> aspectRatio(<span class="type">CGFloat</span>?, contentMode: <span class="type">ContentMode</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span>
</code></pre><p>This function returns <code>some View</code> - the opaque View type we discussed before. It does <em>not</em> return an Image. This is a more generic modifier. So what does this imply? What does this code do?</p><pre><code><span class="type">Image</span>(<span class="string">"cook_hero"</span>, label: <span class="type">Text</span>(<span class="string">"Tim Cook"</span>))
  .<span class="call">aspectRatio</span>(contentMode: .<span class="dotAccess">fit</span>)
  .<span class="call">resizable</span>()
</code></pre><p>Based on the discussion of the modifier function signatures above, <code>aspectRatio</code> would return <code>some View</code> and then <code>resizable()</code> would get called on that - but that modifier is specifically designed for <code>Images</code>, and doesn't exist for <code>View</code>. So therefore <strong>ORDER MATTERS</strong> when dealing with modifiers! You'll want to start with modifiers that are specific to the type you are working on and then expand to ones that are for more generic Views</p><h3>Custom Modifiers</h3><p>In addition to the built in modifiers, you can make your own. In the <code>Week02View.swift</code> file I made my own modifier to wrap each of the sample views with a border and title.</p><pre><code><span class="keyword">struct</span> TitledBorder: <span class="type">ViewModifier</span> {
  
  <span class="keyword">let</span> title: <span class="type">String</span>
  <span class="keyword">let</span> height: <span class="type">Double</span>
  
  <span class="keyword">init</span>(title: <span class="type">String</span>, height: <span class="type">Double</span>) {
    <span class="keyword">self</span>.<span class="property">title</span> = title
    <span class="keyword">self</span>.<span class="property">height</span> = height
  }
  
  <span class="keyword">func</span> body(content: <span class="type">Content</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span> {
    <span class="type">ZStack</span> {
      <span class="type">HStack</span> {
        <span class="type">Spacer</span>()
        content.<span class="call">padding</span>()
      }
      .<span class="call">frame</span>(height: height)
      .<span class="call">overlay</span>(
        <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">16</span>)
          .<span class="call">stroke</span>(<span class="type">Color</span>.<span class="property">black</span>, lineWidth: <span class="number">2</span>)
      ).<span class="call">overlay</span>(
        <span class="type">GeometryReader</span> { geometry <span class="keyword">in</span>
          <span class="type">Text</span>(title).<span class="call">background</span>(<span class="type">Color</span>.<span class="property">white</span>).<span class="call">position</span>(x: geometry.<span class="property">size</span>.<span class="property">width</span>/<span class="number">2</span>, y: <span class="number">0</span>)
        },
        alignment: .<span class="dotAccess">topLeading</span>
      )
    }.<span class="call">padding</span>()
    
  }
}
</code></pre><p>This custom code uses a few layout managers we haven't talked about yet - <code>VStack</code> will stack the elements vertically (<code>HStack</code> is the reverse of this, where it stacks them horizontally), and <code>ZStack</code> will sort views perpendicular to the screen - the first element is inline with the screen, and subsequent views come closer to the viewer.</p><p>This example also uses <code>GeometryReader</code> which a view that can provide you some positional and size information about the views it wraps. This sort of information usually isn't needed with SwiftUI but can come in handy in certain cases. Here I wanted to get a bit more refined placement of the title text.</p><p>In order to use this modifier, I extended the <code>View</code> type to add a modifier that would call my custom code:</p><pre><code><span class="keyword">extension</span> <span class="type">View</span> {
  <span class="keyword">func</span> titledBorder(title: <span class="type">String</span>, height: <span class="type">Double</span> = <span class="number">90.0</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span> {
    <span class="keyword">self</span>.<span class="call">modifier</span>(<span class="type">TitledBorder</span>(title: title, height: height))
  }
}
</code></pre><p>With this in hand, I can call:</p><pre><code><span class="type">Text</span>(<span class="string">"Your text here"</span>)
  .<span class="call">titledBorder</span>(title: <span class="string">"Text View"</span>)
</code></pre><p>to wrap the view, or to specify a height for the titled border:</p><pre><code><span class="type">Text</span>(<span class="string">"Your text here"</span>)
  .<span class="call">titledBorder</span>(title: <span class="string">"Text View"</span>, height: <span class="number">150</span>)
</code></pre><p>Notice how I've only declared one function in my extension, but I'm calling it two ways? This is because the height has a default value (90), so if I don't include that argument in my call, Swift just uses the default.<br><br><br>In the next module we'll discuss how state is carried between views in SwiftUI.</p><p style="float: left">Previous:  <A HREF="../../Week02/01-TheDelegatePattern/index.html">The Delegate Pattern</A></p><p style="float: right">Next:  <A HREF="../../Week02/03-SwiftUIState/index.html">SwiftUI State</A></p><BR/><BR/></div><leftside><u><p>Week 2</p></u><div class="weekSection"><ul><li><div class="comment-container"><div class="tocItem"><a id="Week 02 Overview" href="../../Week02/00-Week02Overview/index.html">Week 02 Overview</a></div><div class="chain chain-bottom"></div></div></li><li><div class="comment-container"><div class="chain chain-top"></div><div class="tocItem"><a id="The Delegate Pattern" href="../../Week02/01-TheDelegatePattern/index.html">The Delegate Pattern</a></div><div class="chain chain-bottom"></div></div></li><li><div class="comment-container"><div class="chain chain-top"></div><div class="tocItem"><a id="Introduction to SwiftUI" href="../../Week02/02-IntroductionToSwiftUI/index.html">Introduction to SwiftUI</a></div><div class="chain chain-bottom"></div></div></li><li><div class="comment-container"><div class="chain chain-top"></div><div class="tocItem"><a id="SwiftUI State" href="../../Week02/03-SwiftUIState/index.html">SwiftUI State</a></div><div class="chain chain-bottom"></div></div></li><li><div class="comment-container"><div class="chain chain-top"></div><div class="tocItem"><a id="The SwiftUI Environment" href="../../Week02/04-TheSwiftUIEnvironment/index.html">The SwiftUI Environment</a></div><div class="chain chain-bottom"></div></div></li><li><div class="comment-container"><div class="chain chain-top"></div><div class="tocItem"><a id="The App Lifecycle" href="../../Week02/05-TheAppLifecycle/index.html">The App Lifecycle</a></div><div class="chain chain-bottom"></div></div></li><li><div class="comment-container"><div class="chain chain-top"></div><div class="tocItem"><a id="Xcode Tips and Tricks" href="../../Week02/06-XcodeTipsAndTricks/index.html">Xcode Tips and Tricks</a></div></div></li></ul></div></leftside><footer><p>Generated with ❤️ using <a href="https://github.com/johnsundell/publish">Publish</a></p><p>© 2023-2024 Josh Steele (rsteele3@jhu.edu) <a href="mailto:"(rsteele3@jhu.edu)""></a></p><p>Last updated February 1, 2025 at 3:31 PM</p><p><a href="https://mastodon.social/@hococoder" target="_blank">My Mastodon</a> | <a href="https://github.com/hococoder" target="_blank">My GitHub</a> | <a href="https://ep.jhu.edu" target="_blank">Whiting School EPP</a> | <a href="https://canvas.jhu.edu" target="_blank">JHU Canvas</a></p></footer></div></body></html>